<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hitachi FU Steuerung</title>
  <style>
    /* Dein bisheriges CSS ‚Äì unver√§ndert */
    html,
    body {
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", Tahoma, sans-serif;
      background: #f4f4f4;
      overscroll-behavior: none;
    }

    .container {
      background: #fff;
      padding: 30px;
      margin: 30px auto;
      border-radius: 12px;
      width: 90%;
      max-width: 500px;
      text-align: center;
    }

    h2 {
      color: #333;
    }

    input[type=range],
    input[type=number],
    select {
      width: 100%;
      margin-top: 20px;
      font-size: 18px;
      padding: 8px;
      box-sizing: border-box;
    }

    #slider {
      /* touch-action: manipulation; */
    }

    #val {
      font-size: 24px;
      font-weight: bold;
      color: #2196F3;
    }

    #status {
      margin-top: 15px;
      font-size: 20px;
      padding: 15px;
      border-radius: 10px;
      background-color: #ccc;
      color: #fff;
      width: 100%;
      box-sizing: border-box;
    }

    .status-aktiv {
      background-color: #4CAF50;
    }

    .status-warte {
      background-color: #FF9800;
    }

    .status-stop {
      background-color: #f44336;
    }

    #stop {
      margin-top: 20px;
      width: 100%;
      height: 60px;
      font-size: 22px;
      font-weight: bold;
      background-color: #f44336;
      color: white;
      border: none;
      border-radius: 8px;
      display: flex;
      max-width: 100%;
      box-sizing: border-box;
      justify-content: center;
      align-items: center;
      user-select: none;
    }

    #stop:active {
      background-color: #d32f2f;
    }

    #buttonRow {
      margin-top: 20px;
      display: flex;
      max-width: 100%;
      box-sizing: border-box;
      justify-content: space-between;
      gap: 10px;
    }

    #totmann,
    #start {
      width: 48%;
      height: 60px;
      font-size: 20px;
      font-weight: bold;
      border-radius: 8px;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    #totmann {
      background-color: #FFEB3B;
      color: black;
    }

    #totmann.active {
      background-color: #FBC02D;
    }

    #start {
      background-color: #4CAF50;
    }

    #start.active {
      background-color: #388E3C;
    }

    #zeitContainer {
      margin-top: 30px;
      text-align: left;
    }

    #zeitContainer label {
      font-weight: bold;
      font-size: 18px;
    }

    #zeitContainer input[type=number] {
      margin-top: 8px;
    }

    #zeitContainer button {
      margin-top: 10px;
      width: 100%;
      height: 40px;
      font-size: 18px;
      font-weight: bold;
      background-color: #2196F3;
      color: white;
      border: none;
      border-radius: 6px;
    }

    #zeitContainer button:active {
      background-color: #1976D2;
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
    }

    .switch input {
      display: none;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #A8DADC;
      transition: 0.4s;
      border-radius: 34px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: 0.4s;
      border-radius: 50%;
    }

    input:checked+.slider {
      background-color: #A8DADC;
    }

    input:checked+.slider:before {
      transform: translateX(26px);
    }
  </style>
</head>

<body>
  <div class="container">
    <h2>Hitachi FU Steuerung</h2>
    <p><strong>Drehzahl:</strong> <span id="val">0</span>%</p>
    <input type="range" min="0" max="100" value="0" id="slider" />

    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; gap: 20px;">
      <div>
        <label><strong>Drehrichtung:</strong></label><br />
        <label class="switch">
          <input type="checkbox" id="directionToggle" />
          <span class="slider"></span>
        </label>
        <span id="directionLabel">IUZ</span>
      </div>
      <div>
        <label><strong>Durchmesser:</strong></label><br />
        <label class="switch">
          <input type="checkbox" id="diameterToggle" />
          <span class="slider"></span>
        </label>
        <span id="diameterLabel">7,5m</span>
      </div>
      <div>
        <label><strong>Geschwindigkeit:</strong></label><br />
        <span id="speedDisplay">0,00 m/s</span>
      </div>
    </div>

    <div id="zeitContainer">
      <label for="zeitInput">Zeit/Umdrehung (Sekunden):</label>
      <input type="number" id="zeitInput" min="0" step="0.01" placeholder="z.‚ÄØB. 70" />
      <button id="zeitButton">Zeit √ºbernehmen</button>
    </div>

    <div id="status">Status: Unbekannt</div>


    <div id="stop">‚èπ STOP</div>

    <div id="buttonRow">
      <div id="totmann">Totmann</div>
      <div id="start">‚ñ∂ Start</div>
    </div>


    <div id="presetControls" style="margin-top: 30px; text-align: left;">
      <label for="presetName" style="font-weight: bold; font-size: 18px;">üìù Preset speichern:</label>
      <input type="text" id="presetName" placeholder="z.‚ÄØB. 1. Fahrt, Bild 1"
        style="width: 100%; padding: 8px; margin-top: 5px; box-sizing: border-box;" />

      <button id="savePreset"
        style="margin-top: 10px; width: 100%; height: 40px; font-size: 18px; font-weight: bold; background-color: #2196F3; color: white; border: none; border-radius: 6px;">
        üíæ Preset speichern
      </button>

      <label for="presetSelect" style="display: block; margin-top: 20px; font-weight: bold; font-size: 18px;">üìÇ Preset
        laden:</label>
      <select id="presetSelect" style="width: 100%; padding: 8px; box-sizing: border-box; margin-top: 5px;">
        <option value="">-- Bitte w√§hlen --</option>
      </select>

      <div style="margin-top: 10px; display: flex; gap: 10px;">
        <div id="playPreset" style="flex: 1; font-size: 16px; background-color: #4CAF50; color: white; border-radius: 6px; height: 36px;
              display: flex; align-items: center; justify-content: center;">
          üîÅ Wiedergabe
        </div>

        <button id="deletePreset"
          style="flex: 1; font-size: 16px; background-color: #f44336; color: white; border: none; border-radius: 6px; height: 36px;">
          üóëÔ∏è L√∂schen
        </button>
      </div>

    </div>

    <div style="margin-top: 20px;">
      <button id="downloadPresetsBtn"
        style="width: 100%; height: 40px; font-size: 18px; font-weight: bold; background-color: #2196F3; color: white; border: none; border-radius: 6px;">
        üì• Alle Presets herunterladen (JSON)
      </button>
    </div>

    <div style="margin-top: 20px;">
      <label for="importPresetsInput" style="font-weight: bold; display: block; margin-bottom: 5px;">
        üìÇ Presets importieren (JSON):
      </label>
      <input type="file" id="importPresetsInput" accept=".json"
        style="width: 100%; padding: 8px; box-sizing: border-box;" />
    </div>
  </div>
  </div>

  <script>
    const totmannBtn = document.getElementById('totmann');
    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');
    const statusDiv = document.getElementById('status');
    const slider = document.getElementById('slider');
    const valDisplay = document.getElementById('val');
    const speedDisplay = document.getElementById('speedDisplay');
    const zeitInput = document.getElementById('zeitInput');
    const zeitButton = document.getElementById('zeitButton');
    const diameterToggle = document.getElementById('diameterToggle');
    const diameterLabel = document.getElementById('diameterLabel');
    const directionToggle = document.getElementById('directionToggle');
    const directionLabel = document.getElementById('directionLabel');
    const presetNameInput = document.getElementById('presetName');
    const savePresetBtn = document.getElementById('savePreset');
    const presetSelect = document.getElementById('presetSelect');
    const playPresetBtn = document.getElementById('playPreset');
    const deletePresetBtn = document.getElementById('deletePreset');


    let totmannActive = false;
    let totmannTimer = null;
    let dutyCycle = 0;
    let scheibenDurchmesser = 7.5;
    let recordingActive = false;
    let recordingStartTime = null;
    let recordingActions = [];


    function updateSpeedDisplay() {
      const umdrehzeit100 = 38;
      const rpmMax = 60 / umdrehzeit100;
      const rpm = (dutyCycle / 100) * rpmMax;
      const umfang = Math.PI * scheibenDurchmesser;
      const geschwindigkeit = (umfang * rpm) / 60;
      speedDisplay.innerText = geschwindigkeit.toFixed(3) + " m/s";
    }

    function updateZeitFromDuty(pwm) {
      if (pwm > 0) {
        const umdrehzeit = 38 * (100 / pwm);
        zeitInput.value = umdrehzeit.toFixed(2);
      } else {
        zeitInput.value = "";
      }
    }

    function fetchDutyCycle() {
      fetch('/getDuty')
        .then(response => response.text())
        .then(val => {
          let dutyVal = parseInt(val);
          if (isNaN(dutyVal)) dutyVal = 0;
          slider.value = dutyVal;
          valDisplay.innerText = dutyVal;
          dutyCycle = dutyVal;
          updateSpeedDisplay();
          updateZeitFromDuty(dutyVal);
        })
        .catch(() => {
          slider.value = 0;
          valDisplay.innerText = 0;
          dutyCycle = 0;
          updateSpeedDisplay();
          updateZeitFromDuty(0);
        });
    }

    window.addEventListener('load', () => {
      fetchDutyCycle();
      updateSpeedDisplay();

      diameterToggle.checked = false;
      scheibenDurchmesser = 7.5;
      diameterLabel.textContent = "7,5m";

      directionToggle.checked = false;
      directionLabel.textContent = 'IUZ';

      loadPresets();
    });

    slider.addEventListener('input', (e) => {
      const duty = parseInt(e.target.value);
      if (!isNaN(duty)) {
        valDisplay.innerText = duty;
        dutyCycle = duty;
        fetch('/set', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: 'duty=' + encodeURIComponent(duty)
        }).catch(() => { });
        updateSpeedDisplay();
        updateZeitFromDuty(duty);
      }
    });

    zeitButton.addEventListener('click', () => {
      let zeit = parseFloat(zeitInput.value);
      if (isNaN(zeit) || zeit <= 0) {
        alert("Bitte eine g√ºltige Zeit gr√∂√üer 0 eingeben.");
        return;
      }
      fetch('/getPWMforTime?time=' + encodeURIComponent(zeit))
        .then(response => {
          if (!response.ok) throw new Error("Serverfehler");
          return response.text();
        })
        .then(pwmText => {
          const pwm = parseInt(pwmText);
          if (isNaN(pwm)) throw new Error("Ung√ºltige Serverantwort");
          slider.value = pwm;
          valDisplay.innerText = pwm;
          dutyCycle = pwm;
          updateSpeedDisplay();
          fetch('/set', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: 'duty=' + encodeURIComponent(pwm)
          }).catch(() => { });
        })
        .catch(err => {
          alert("Fehler beim Abrufen der PWM: " + err.message);
        });
    });

    diameterToggle.addEventListener('change', () => {
      scheibenDurchmesser = diameterToggle.checked ? 8.5 : 7.5;
      diameterLabel.textContent = scheibenDurchmesser + "m";
      fetch('/setDiameter', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: 'd=' + encodeURIComponent(scheibenDurchmesser)
      }).catch(() => { });
      updateSpeedDisplay();
    });

    directionToggle.addEventListener('change', () => {
      const direction = directionToggle.checked ? 'GUZ' : 'IUZ';
      directionLabel.textContent = direction;
      currentDirection = direction;
    });

    // --- TOTMANN-FUNKTION ---

    // --- Signal an Server senden ---
    function sendTotmannSignal() {
      fetch('/deadman', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: 'alive=1'
      }).catch(() => { });

      // ‚ûï NEU: Richtung senden, wenn sie gesetzt ist
      if (currentDirection) {
        fetch('/direction', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: 'dir=' + encodeURIComponent(currentDirection.toLowerCase())
        }).catch(() => { });
      }
    }

    // --- Totmann starten ---
    function startTotmann() {
      if (totmannActive) return;
      totmannActive = true;
      totmannBtn.classList.add('active');
      sendTotmannSignal();
      totmannTimer = setInterval(sendTotmannSignal, 200);
    }

    // --- Totmann stoppen ---
    function stopTotmann() {
      if (!totmannActive) return;
      totmannActive = false;
      totmannBtn.classList.remove('active');
      if (totmannTimer) {
        clearInterval(totmannTimer);
        totmannTimer = null;
      }
      // kein Alert ‚Äì 8266-Version war hier still
      console.log("Totmann losgelassen");
    }

    // --- Maus + Touch Events ---
    totmannBtn.addEventListener('mousedown', startTotmann);
    totmannBtn.addEventListener('mouseup', stopTotmann);
    totmannBtn.addEventListener('mouseleave', stopTotmann);
    totmannBtn.addEventListener('touchstart', startTotmann);
    totmannBtn.addEventListener('touchend', stopTotmann);


    // --- START-BUTTON ---
    startBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();

      recordingActions = [];
      recordingStartTime = Date.now();
      recordingActive = true;

      fetch('/start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: 'start=1'
      })
        .then(response => {
          if (!response.ok) throw new Error("Start fehlgeschlagen");
          startBtn.classList.add('active');
          setTimeout(() => startBtn.classList.remove('active'), 500);
        })
        .catch(() => {
          alert("Start fehlgeschlagen. Totmann aktiv?");
          recordingActive = false;
        });
    });

    // --- STOP-BUTTON: Touch ---
    stopBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      fetch('/stop', { method: 'POST' })
        .then(() => {
          startBtn.classList.remove('active');
          if (recordingActive && recordingStartTime) {
            const elapsed = Date.now() - recordingStartTime;
            recordingActions.push({ type: 'stop', time: elapsed });
            recordingActive = false;
            recordingStartTime = null;
          }
        })
        .catch(() => {
          alert("Stopp fehlgeschlagen.");
        });
    });

    // --- STOP-BUTTON: Maus ---
    stopBtn.addEventListener('mousedown', (e) => {
      e.preventDefault();
      fetch('/stop', { method: 'POST' })
        .then(() => {
          startBtn.classList.remove('active');
          if (recordingActive && recordingStartTime) {
            // üëâ Aufnahme beenden
            const elapsed = Date.now() - recordingStartTime;
            recordingActions.push({ type: 'stop', time: elapsed });
            recordingActive = false;
            recordingStartTime = null;
          }
        })
        .catch(() => {
          alert("Stopp fehlgeschlagen.");
        });
    });

    function updateStatus() {
      fetch('/status')
        .then(response => response.text())
        .then(data => {
          statusDiv.classList.remove('status-aktiv', 'status-warte', 'status-stop');
          if (data === "aktiv") {
            statusDiv.classList.add('status-aktiv');
            statusDiv.innerText = "‚úÖ Status: AKTIV";
          } else if (data === "warte") {
            statusDiv.classList.add('status-warte');
            statusDiv.innerText = "‚è≥ Status: WARTE AUF START";
          } else {
            statusDiv.classList.add('status-stop');
            statusDiv.innerText = "‚èπ Status: STOP";
          }
        })
        .catch(() => {
          statusDiv.classList.add('status-stop');
          statusDiv.innerText = "‚õî Status: Verbindung verloren";
        });
    }

    document.addEventListener('keydown', (e) => {
      const tag = document.activeElement.tagName;
      if (['INPUT', 'TEXTAREA', 'BUTTON', 'SELECT'].includes(tag)) return;

      switch (e.key) {
        case ' ':
          e.preventDefault();
          if (!totmannActive) startTotmann();
          break;

        case 'Enter':
          e.preventDefault();
          if (statusDiv.classList.contains('status-aktiv')) {
            fetch('/stop', { method: 'POST' })
              .then(() => startBtn.classList.remove('active'))
              .catch(() => alert("Stopp fehlgeschlagen."));
          } else {
            fetch('/start', { method: 'POST' })
              .then(response => {
                if (!response.ok) throw new Error("Start fehlgeschlagen");
                startBtn.classList.add('active');
                setTimeout(() => startBtn.classList.remove('active'), 500);
              })
              .catch(() => alert("Start fehlgeschlagen. Totmann aktiv?"));
          }
          break;

        case 's':
          e.preventDefault();
          adjustDutyCycle(1);
          break;

        case 'l':
          e.preventDefault();
          adjustDutyCycle(-1);
          break;

        case 'd':
          e.preventDefault();
          directionToggle.checked = !directionToggle.checked;
          directionToggle.dispatchEvent(new Event('change'));
          break;
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === ' ') stopTotmann();
    });

    function adjustDutyCycle(change) {
      let newDuty = dutyCycle + change;
      if (newDuty < 0) newDuty = 0;
      if (newDuty > 100) newDuty = 100;
      slider.value = newDuty;
      valDisplay.innerText = newDuty;
      dutyCycle = newDuty;
      fetch('/set', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ duty: currentDuty })
      })
        .catch(err => console.error('Fehler bei /set:', err));
      updateSpeedDisplay();
      updateZeitFromDuty(newDuty);
    }

    // Aufnahme starten
    function startRecording() {
      recordingActive = true;
      recordingStartTime = Date.now();
      recordingActions = [];
    }

    function recordStart() {
      if (!recordingActive) return;

      const elapsed = Date.now() - recordingStartTime;

      // Falls Werte noch nicht initialisiert sind, hole sie aus der UI:
      if (direction == null) {
        direction = directionToggle.checked ? 'GUZ' : 'IUZ';
      }
      if (dutyCycle == null) {
        dutyCycle = parseInt(slider.value);
      }

      // Sicherstellen, dass kein doppelter Start direkt hintereinander entsteht:
      if (
        recordingActions.length > 0 &&
        recordingActions[recordingActions.length - 1].type === 'start'
      ) {
        return; // vermeidet doppelte start-Aktion
      }

      // Aufnahmeaktion hinzuf√ºgen
      recordingActions.push({
        type: 'start',
        time: elapsed,
        duty: currentDuty,
        direction: currentDirection
      });
    }

    // Aufnahme stoppen
    function stopRecording() {
      if (!recordingActive) return;
      const elapsed = Date.now() - recordingStartTime;
      recordingActions.push({ type: 'stop', time: elapsed });

      recordingActive = false;
      recordingStartTime = null;
    }

    // Preset speichern
    savePresetBtn.addEventListener('click', () => {
      const name = presetNameInput.value.trim();
      if (!name) {
        alert('Bitte einen g√ºltigen Presetnamen eingeben.');
        return;
      }

      if (localStorage.getItem('preset_' + name)) {
        if (!confirm(`Preset "${name}" existiert bereits. √úberschreiben?`)) {
          return;
        }
      }

      if (recordingActions.length === 0) {
        alert('Keine Aktionen zum Speichern vorhanden. Bitte zuerst Start dr√ºcken und Aktionen durchf√ºhren.');
        return;
      }

      recordingActions.sort((a, b) => a.time - b.time);
      localStorage.setItem('preset_' + name, JSON.stringify(recordingActions));
      loadPresets();
      presetNameInput.value = '';
      alert(`Preset "${name}" gespeichert.`);
    });

    // Presets laden (Dropdown aktualisieren)
    function loadPresets() {
      presetSelect.innerHTML = '<option value="">-- Preset w√§hlen --</option>';
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('preset_')) {
          const name = key.replace('preset_', '');
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          presetSelect.appendChild(option);
        }
      }
    }

    // Preset abspielen ‚Äì Multitouch-kompatibel
    function handlePlayPreset() {
      const selected = presetSelect.value;
      if (!selected) {
        alert("Bitte ein Preset ausw√§hlen.");
        return;
      }

      const raw = localStorage.getItem('preset_' + selected);
      if (!raw) {
        alert("Preset nicht gefunden.");
        return;
      }

      let actions;
      try {
        actions = JSON.parse(raw);
      } catch (err) {
        alert("Preset ung√ºltig.");
        return;
      }

      // visuelles Feedback (optional)
      playPresetBtn.style.opacity = "0.6";

      // keine Buttons mehr "disable"n ‚Äì das verhindert Multitouch!
      // => stattdessen nur visuell anzeigen, dass etwas l√§uft
      startBtn.classList.add('disabled');
      stopBtn.classList.add('disabled');

      actions.forEach(action => {
        setTimeout(() => {
          switch (action.type) {
            case 'start':
              if ('direction' in action) {
                currentDirection = action.direction;
                const isGUZ = currentDirection === 'GUZ';
                directionToggle.checked = isGUZ;
                directionLabel.textContent = currentDirection;
              }
              if ('duty' in action) {
                currentDuty = action.duty;
                slider.value = currentDuty;
                valDisplay.innerText = currentDuty;
                fetch('/set', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ duty: currentDuty })
                }).catch(() => { });
                updateSpeedDisplay();
                updateZeitFromDuty(currentDuty);
              }

              fetch('/start', { method: 'POST' }).catch(() => { });
              break;

            case 'stop':
              fetch('/stop', { method: 'POST' }).catch(() => { });
              break;
          }
        }, action.time);
      });

      const maxTime = Math.max(...actions.map(a => a.time));
      setTimeout(() => {
        playPresetBtn.style.opacity = "1";
        startBtn.classList.remove('disabled');
        stopBtn.classList.remove('disabled');
      }, maxTime + 500);
    }

    // Touch-Unterst√ºtzung:
    playPresetBtn.addEventListener('touchstart', handlePlayPreset);
    playPresetBtn.addEventListener('mousedown', handlePlayPreset);


    // Presets exportieren
    document.getElementById('downloadPresetsBtn').addEventListener('click', () => {
      const exportObj = {};
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('preset_')) {
          exportObj[key] = localStorage.getItem(key);
        }
      }

      if (Object.keys(exportObj).length === 0) {
        alert("Keine Presets zum Herunterladen vorhanden.");
        return;
      }

      const jsonStr = JSON.stringify(exportObj, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'presets.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // Presets importieren
    document.getElementById('importPresetsInput').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const imported = JSON.parse(e.target.result);
          let count = 0;
          for (const key in imported) {
            if (key.startsWith('preset_')) {
              localStorage.setItem(key, imported[key]);
              count++;
            }
          }
          if (count > 0) {
            loadPresets();
            alert(count + " Preset(s) importiert.");
          } else {
            alert("Keine g√ºltigen Presets gefunden.");
          }
        } catch (err) {
          alert("Fehler beim Import: " + err.message);
        }
      };
      reader.readAsText(file);
    });

    // Preset l√∂schen
    document.getElementById('deletePreset').addEventListener('click', () => {
      const selected = presetSelect.value;
      if (!selected) {
        alert("Bitte ein Preset ausw√§hlen.");
        return;
      }

      if (confirm(`Preset "${selected}" wirklich l√∂schen?`)) {
        localStorage.removeItem('preset_' + selected);
        loadPresets();
        alert(`Preset "${selected}" gel√∂scht.`);
      }
    });


    setInterval(updateStatus, 500);
  </script>
</body>

</html>